<style>
  /* Make each citation a 2-column row: [thumb] [citation text] */
  .pub-list-item.view-citation {
    display: grid;
    grid-template-columns: 110px 1fr;
    gap: 12px;
    align-items: start;
  }
  .pub-list-item.view-citation.no-thumb {
    display: block;                 /* fall back to normal if no image */
  }
  .pub-thumb {
    width: 110px; height: 110px;
    object-fit: cover;
    border-radius: 8px;
    background: #f2f2f2;
  }
</style>

<script>
(function addPubThumbs(){
  const items = Array.from(document.querySelectorAll('.pub-list-item.view-citation'));
  if (!items.length) return;

  const names = ['featured','teaser','thumb','thumbnail','cover','image'];
  const exts  = ['png','webp','jpg','jpeg','gif'];

  items.forEach(async (el) => {
    try {
      // Find the paper link (points to /publication/<slug>/)
      const a = el.querySelector('a[href*="/publication/"]') || el.querySelector('a.underline');
      if (!a) { el.classList.add('no-thumb'); return; }

      // Build the base folder URL.
      const base = new URL(a.getAttribute('href'), location.origin);
      if (!base.pathname.endsWith('/')) base.pathname += '/';

      // Try common filenames in that folder, stop at first that loads.
      const src = await findExistingImage(base, names, exts);
      if (!src) { el.classList.add('no-thumb'); return; }

      // Create <img> and insert as first column; wrap with the paper link.
      const img = document.createElement('img');
      img.className = 'pub-thumb';
      img.loading = 'lazy';
      img.decoding = 'async';
      img.alt = 'thumbnail';
      img.src = src;

      const link = document.createElement('a');
      link.href = a.href;         // or point to PDF if you prefer
      link.appendChild(img);

      el.insertBefore(link, el.firstChild);
    } catch {
      el.classList.add('no-thumb');
    }
  });

  function findExistingImage(base, names, exts){
    // Try sequentially to avoid hammering the server.
    const candidates = [];
    for (const n of names) for (const e of exts) {
      const u = new URL(base.href);
      u.pathname = u.pathname + `${n}.${e}`;
      candidates.push(u.href);
    }
    return trySequential(candidates, testImg);
  }

  function testImg(url){
    return new Promise((resolve, reject) => {
      const i = new Image();
      i.onload = () => resolve(url);
      i.onerror = reject;
      i.src = url;
    });
  }

  async function trySequential(arr, tester){
    for (const it of arr) {
      try { const ok = await tester(it); return ok; } catch {}
    }
    return null;
    }
})();
</script>
